# TTS 要求定義書

Date: 2026年1月9日
Tags: .Development.AI.Project.TTS (https://www.notion.so/Development-AI-Project-TTS-2be7c88ab54d809587d7d32ad3540143?pvs=21), .Study.University.3YLP.AIApplication (https://www.notion.so/Study-University-3YLP-AIApplication-2bd7c88ab54d80e3bc94c9eff4c0e05a?pvs=21)
created: 2026年1月9日 16:28
Last Edited: 2026年1月14日 20:54

## 1. プロジェクト概要（更新）

- 研究タイトル
    - 少量特徴量を用いた音声合成モデルの構築
- 背景
    - 以前の実験では、日本語コーパス100文中に37種類のユニーク音素があり、貪欲法により「4文で37音素をすべてカバーする組」が存在することを確認済み。
    - 一方で、音声合成モデルの構築に時間をかけたにもかかわらず音声合成に失敗し、品質評価まで到達できなかったという課題があった。
- 今回の前提
    - ベースラインとしては、日本語でモデル構築・fine‑tuningが実績豊富で、客観指標（MCD, F0 RMSE, CERなど）の評価スクリプトが既に整っている枠組み（例: ESPnet2‑TTSレシピ）を採用する方向を想定。

---

## 2. 目的・MVP定義（更新）

- 研究の主目的
    - 「音素カバレッジ」と「コーパス設計（4文 vs 80文など）」が、fine‑tuningされた日本語TTSモデルの出力品質にどのような影響を与えるかを、客観指標を用いて明らかにする。
- 技術的学習目標
    - 少量日本語コーパスを用いたTTS fine‑tuningパイプライン（前処理 → 学習 → 合成 → 評価）を、自力で一通り構築・運用できるようになる。
- MVP定義（Must要件）
    - 事前学習済み日本語TTSモデルを利用し、以下4条件のコーパスで**fine‑tuning → 合成 → 客観評価**まで到達すること。
        1. 100文コーパスのうち学習80文（8:2分割を想定）
        2. 37音素を全てカバーする4文コーパス（貪欲法で既に特定済み）
        3. ランダムに選んだ4文コーパス（含有音素数を別途計測）
        4. 「音素特徴量上位10文」コーパス（音素分布・情報量などから上位10文を選定）
    - 各条件でテスト文を合成し、MCD / log‑F0 RMSE / CER などの客観指標を算出して比較する。

---

## 3. スコープ・制約（更新）

- 対象
    - 言語: 日本語。
    - データ: JVS parallel100 の jvs002 話者（100文）を基盤とし、そこから4つのコーパス条件を構成する。
- モデル
    - 事前学習済み日本語TTSモデルをベースラインとし、from‑scratchは本フェーズでは必須としない（時間とリスクを抑える）。
- 実行環境
    - ローカルGPU（RTX 4070 Ti）での実行を想定。学習時間が長くなりすぎないよう、fine‑tuningステップ数とバッチサイズは事前に上限を決める。

---

## 4. 実験設計：説明変数・目的変数・評価方法（音素中心版）

## 4.1 説明変数（独立変数）

1. コーパス設計（4条件）

| **条件名** | **内容** | **期待される特徴** |
| --- | --- | --- |
| 80文コーパス | 100文を8:2で分割したうちの学習80文 | 分布的にバランス良い、データ量最大 |
| 37音素4文 | 37音素を全てカバーする4文 | 音素カバレッジ最大・データ量最小 |
| ランダム4文 | ランダムに選んだ4文（含有音素数は計測） | カバレッジ・分布ともに無作為 |
| 上位10文 | 「音素特徴量」上位10文（定義は後述） | 情報量の高い文集合を仮定 |
- 「音素特徴量上位10文」の例
    - 候補指標
        - 各文の含有音素数（種類数）
        - 全体分布に対するレア音素の含有数
        - 文内の音素ビッグラム／トライグラムの多様性など。
    - シンプルには「ユニーク音素数 + レア音素数」でスコアリングし、上位10文を選ぶ。
1. 特徴量・前処理
- 音素ラベル
    - 既存の日本語TTSフロントエンド（例: pyopenjtalk）で音素列を取得し、37音素のラベル体系にマッピング。
- 評価用にも「各文の音素分布・頻度」を算出しておき、品質指標との相関を後で見る。
1. 学習条件
- fine‑tuningステップ数（例）
    - 80文コーパス: 5k〜10k steps
    - 4文/10文コーパス: 1k〜3k steps
- 学習率・optimizerはベースライン実装の推奨値を基本踏襲。

## 4.2 目的変数（従属変数）

- 音質・自然さ
    - MCD（dB）: スペクトル類似度。
    - log‑F0 RMSE: ピッチ輪郭の誤差。
- 明瞭性
    - CER または WER: ASR経由の文字/単語エラー率。
- 学習効率
    - 各条件ごとの学習所要時間・ステップ数。

## 4.3 評価方法

- テストセット
    - 100文コーパス中から、4条件すべてで「未学習」となるテスト文を10〜20文選定（既存の20%テスト分割を流用してもよい）。
- 手順
    1. 各条件で同一テスト文を合成。
    2. テスト音声と自然音声ペアに対して、ESPnet2‑TTS等の **`evaluate_mcd.py`**, **`evaluate_f0.py`**, **`evaluate_asr.sh`** などのスクリプトを応用して客観指標を算出。
    3. 条件ごとの平均値と分散を表・図に整理し、「音素カバレッジ vs 品質」「データ量 vs 品質」の傾向を分析。

---

## 5. ユーザー価値（音素実験としてのアップデート）

- 将来の自声TTS構築時に、「37音素をカバーする数文＋少量追加」でどこまで品質を出せるかの目安を提供できる。
- 音素カバレッジと客観品質指標の関係を示すことで、「収録をどこまで削ってもよいか？」の意思決定に役立つ。
- 学習・評価パイプラインを確立することで、今後は「音素以外の特徴量（アクセント、韻律など）」に対象を広げるための土台になる。

---

## 6. タスク（ToDo）アップデート

- ［］ 100文の音素ラベルから、37音素インベントリと各文の音素分布を再確認し、JSON/CSVで保存
- ［］ 37音素カバー4文・ランダム4文・上位10文・80文の文IDリストを確定し、メタデータにタグ付け
- ［］ ベースライン日本語TTS実装（候補: ESPnet2‑TTS日本語レシピ等）を選定し、事前学習モデル＋評価スクリプト一式が動く状態を作る。
- ［］ 各条件でfine‑tuning → 合成を行う **`run_experiment_<condition>.sh`** / **`.py`** を作成
- ［］ 全条件でMCD / log‑F0 RMSE / CERを一括計算する **`evaluate_all_conditions.py`** を作成
- ［］ 結果を図表とともにドキュメント化し、「最小限の音素・コーパス設計指針」として整理